# Lesson Learn
- LIBC
- pwninit
- PIE on Linux Binary
    - Position-Independent Executables
    - vs ASLR
- Makefile
- ROP
    - ret2main
    - system() and Stack Alighment
        - https://uchan.hateblo.jp/entry/2018/02/16/232029
- ROPgadget
- GOT and PLT
    - https://keichi.dev/post/plt-and-got/
- gdb-peda
    - pattern_create
    - pattern_offset
- pwntools
    - recv(6)
        comination of `recvline()`, trim and padding
        ```python
        a = recvline()
        print(len(a))
        # 6
        recv(6).ljust(8,b"\x00")
        ```
    - type: `bytes` and `len()`
        You can use len() to bytes value.  
        `len()` can adjust to each type and calculate a length of value as the type.  
        ```python
        a = 123
        b ="123"
        c = 0x123
        d = b'123\x89\xe3\x81\xad456'

        # print("int : " + len(a)) #error
        print("string : " + str(len(b)))
        # print("hex : " + str(len(c))) #error
        print("bytes : " + str(len(d)))

        #string : 3
        #bytes : 10
        ```
    - `u64`
        In pwntools, u64 refers to an "unpack 64-bit" operation, and it's used to convert a byte string (sequence of 8 bytes) into an unsigned 64-bit integer. The u64 function is part of pwntools' utility functions for binary data manipulation.

Here's a basic example of using u64:

python
Copy code
from pwn import *

# Example byte string representing a 64-bit integer
byte_data = b'\x01\x02\x03\x04\x05\x06\x07\x08'

# Unpack the byte string to a 64-bit integer
integer_value = u64(byte_data)

# Print the result
print(f"Unsigned 64-bit integer value: {integer_value}")
In this example:

u64 takes a byte string (byte_data) as input and returns an unsigned 64-bit integer.
The byte_data is assumed to be 8 bytes long, representing a little-endian 64-bit integer.
This function is useful in binary exploitation and CTF challenges where you might encounter serialized data in a specific format, and you need to convert it into its corresponding numerical representation.

Keep in mind that the endianness of the architecture might affect how you interpret the bytes. If the data is big-endian, you might use u64(byte_data, endian='big') instead. Always refer to the documentation of the specific binary or CTF challenge you are working on for details on the expected data format.

- `readelf`
    - `-s`  
        -s or --symbols: Display the symbol table.
- Stack Alighment

# Write Up
1. fix binary
```zsh
$ pwninit --bin ./vuln --libc ./libc.so.6
```

```
$ ldd ./vuln
$ strings libc.so.6 | grep -i version

$ checksec --file=./vuln_patched --format=json | jq .
```

2. ghidra

3. gdb-peda
```
gdb-peda$ continue
gdb-peda$ stack
gdb-peda$ info register
gdb-peda$ info break
gdb-peda$ pattern_create 200 # buffer over flow
gdb-peda$ pattc 200
gdb-peda$
##############################
##############################
gdb-peda$
gdb-peda$ break *0x4006ef # scanf
gdb-peda$ break *0x400770 # return
gdb-peda$ start
gdb-peda$ pattern_create 200
AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA
gdb-peda$ c
# copy-and-paste
...
[-------------------------------------code-------------------------------------]
   0x40076e <do_stuff+150>:     nop
   0x40076f <do_stuff+151>:     leave
=> 0x400770 <do_stuff+152>:     ret
   0x400771 <main>:     push   rbp
   0x400772 <main+1>:   mov    rbp,rsp
[------------------------------------stack-------------------------------------]
0000| 0x7fffffffdcc8 ("AAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA")
0008| 0x7fffffffdcd0 ("RAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA")
0016| 0x7fffffffdcd8 ("ApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA")
0024| 0x7fffffffdce0 ("AAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA")
[------------------------------------------------------------------------------]
...
gdb-peda$ pattern_offset AAQAAm
AAQAAm found at offset: 136
```

4. think about ROP

5. pwntools
- p64 and u64
    "p" stands for packing and "u" stands for unpacking.
    ```
    p8(0)
    b'\x00'
    p32(0xdeadbeef)
    b'\xef\xbe\xad\xde'
    p32(0xdeadbeef, endian='big')
    b'\xde\xad\xbe\xef'
    with context.local(endian='big'): p32(0xdeadbeef)
    b'\xde\xad\xbe\xef'
    ```

- calculate static offset
    ```console
    $ readelf -s ./libc.so.6 | grep puts
    191: 0000000000080a30   512 FUNC    GLOBAL DEFAULT   13 _IO_puts@@GLIBC_2.2.5
    422: 0000000000080a30   512 FUNC    WEAK   DEFAULT   13 puts@@GLIBC_2.2.5
    496: 0000000000126870  1240 FUNC    GLOBAL DEFAULT   13 putspent@@GLIBC_2.2.5
    678: 0000000000128780   750 FUNC    GLOBAL DEFAULT   13 putsgent@@GLIBC_2.10
    1141: 000000000007f260   396 FUNC    WEAK   DEFAULT   13 fputs@@GLIBC_2.2.5
    ```
    pwntools
    ```python
    ...
    libc_base=addr-libc.symbols['puts']
    print("static offset ...")
    print(hex(libc.symbols['puts']))
    # 0x80a30
    ...
    ```
- receive result of the first ROP
    the result is here.  
    ```python
    res = p.recvline()
    print(res)                  # b'0j\xee\x95\x9e\x7f\n'
    print(len(res))             # 7
    print(res.ljust(8,b"\x00")) # b'0j\xee\x95\x9e\x7f\n\x00'
    ```
    However, I don't need the last bytes for a new line which is `\n`.  
    So I trim it.
    ```python
    res = p.recv(6)
    print(res)                  # b'0j\xee\x95\x9e\x7f'
    print(len(res))             # 6
    print(res.ljust(8,b"\x00")) # b'0j\xee\x95\x9e\x7f\x00\x00'
    ```

6. think about the next ROP


# Ref  
- https://papadoxie.github.io/Writeups/PicoCTF/HeresALIBC/HeresALIBC.html  
- https://cashitsuki.com/posts/2021-12-15-pwninit-manually/  
- https://qiita.com/Hashibirokou/items/8d76fc88bd6daaf8f067  
- https://ret2home.github.io/blog/CTF/picoctf-2021/pwn/hereslibc/
 -https://sh0ebill.hatenablog.com/entry/2022/09/08/211727
- https://qiita.com/tobira-code/items/7ae54a22158aea1a8579  
- https://zenn.dev/kusunoki576/articles/a785672cbc4e0a