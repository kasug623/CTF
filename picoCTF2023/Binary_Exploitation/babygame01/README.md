# Lesson  
- `Ghidra`  
    - define "struct" with `Data Type Manager`  
    - how to edit decompile code
- understand an importance of reading assembly and decompiled code
    - read carefully  
    - run the program  
    - use debugger  
    - use rename and redifine functions on disassembler  

# Memo  
1. check  
```zsh
$ file game
game: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=02a3bb43121b1f6fbc2ab9154ab38a9427e19149, for GNU/Linux 3.2.0, not stripped
$
$ checksec --file=./game --output=json | jq .
    {
    "./game": {
        "relro": "partial",
        "canary": "yes",
        "nx": "yes",
        "pie": "no",
        "rpath": "no",
        "runpath": "no",
        "symbols": "yes",
        "fortify_source": "no",
        "fortified": "0",
        "fortify-able": "2"
    }
}
```

2. ghidra  
understand the logic  
- main  
A value for flag is on an address just before area[0].  
```c
undefined4 main(void)
{
    int input;
    undefined4 uVar1;
    int in_GS_OFFSET;
    Player *player;
    int iStack_aa8;
    char isFlag;  // point
    char area [2700]; // point
    int local_14;
    undefined *local_10;

    local_10 = &stack0x00000004;
    local_14 = *(int *)(in_GS_OFFSET + 0x14);
    init_player((Player *)&player);
    init_map(area,(Player *)&player);
    print_map(area,(Player *)&player);
    signal(2,sigint_handler);
    do {
        do {
        input = getchar();
        move_player((Player *)&player,(char)input,area);
        print_map(area,(Player *)&player);
        } while (player != (Player *)0x1d);
    } while (iStack_aa8 != 0x59);
    puts("You win!");
    if (isFlag != '\0') {  // point
        puts("flage");
        win();
        fflush(stdout);
    }
    uVar1 = 0;
    if (local_14 != *(int *)(in_GS_OFFSET + 0x14)) {
        uVar1 = __stack_chk_fail_local();
    }
    return uVar1;
}
```
- init_player()  
```c
void init_player(Player *player)
{
    player->posVertical = 4;
    player->posHorizon = 4;
    player->field_0x8 = 0;
    return;
}
```
- init_map()
```c
void init_map(char *area,Player *player)
{
    int i;
    int j;

    for (i = 0; i < 0x1e; i = i + 1) {
        for (j = 0; j < 0x5a; j = j + 1) {
        if ((i == 0x1d) && (j == 0x59)) {
            area[0xa8b] = 'X';
        }
        else if ((i == player->posVertical) && (j == player->posHorizon)) {
            area[j + i * 0x5a] = player_tile;
        }
        else {
            area[j + i * 0x5a] = '.';
        }
        }
    }
    return;
}
```
- move_player()
```c
void move_player(Player *pos,char input,char *area)
{
    int iVar1;

    if (input == 'l') {
        iVar1 = getchar();
        player_tile = (char)iVar1;
    }
    if (input == 'p') {
        solve_round(area,pos);
    }
                        /* before move, put "." on exPos */
    area[pos->posHorizon + pos->posVertical * 0x5a] = '.'; // point
    if (input == 'w') {
        pos->posVertical = pos->posVertical + -1;
    }
    else if (input == 's') {
        pos->posVertical = pos->posVertical + 1;
    }
    else if (input == 'a') {
        pos->posHorizon = pos->posHorizon + -1;
    }
    else if (input == 'd') {
        pos->posHorizon = pos->posHorizon + 1;
    }
                        /* after move, put "player_tile" on current
                        Pos */
    area[pos->posHorizon + pos->posVertical * 0x5a] = player_tile; // point
    return;
}
```
- solver_round()
```c
void solve_round(char *area,Player *pos)
{
    while (pos->posHorizon != 0x59) {
        if ((int)pos->posHorizon < 0x59) {
        move_player(pos,100,area);
        }
        else {
        move_player(pos,0x61,area);
        }
        print_map(area,pos);
    }
    while (pos->posVertical != 0x1d) {
        if ((int)pos->posHorizon < 0x1d) {
        move_player(pos,0x77,area);
        }
        else {
        move_player(pos,0x73,area);
        }
        print_map(area,pos);
    }
    sleep(0);
    if ((pos->posVertical == 0x1d) && (pos->posHorizon == 0x59)) {
        puts("You win!");
    }
    return;
}
```

3. exploit  
The area is defined with a size of 2700 elements. It is area[2700].  
horizontal: aaaa  
vertical: wwww  
-> Now it's on area[0].  

- stack when "aaa" after "aaaawwww"  
    - pwndbg
    ```
    ──────────────────────────────────────────────────────────────────────────[ DISASM / i386 / set emulate on ]────────────────────────────────────────────────────────────────────────── ► 0x804984e <main+234>    movzx  eax, byte ptr [ebp - 0xa9c]
    0x8049855 <main+241>    test   al, al
    0x8049857 <main+243>    je     main+288                     <main+288>
        ↓
    0x8049884 <main+288>    nop
    0x8049885 <main+289>    mov    eax, 0
    0x804988a <main+294>    mov    edx, dword ptr [ebp - 0xc]
    0x804988d <main+297>    sub    edx, dword ptr gs:[0x14]
    0x8049894 <main+304>    je     main+311                     <main+311>
        ↓
    0x804989b <main+311>    lea    esp, [ebp - 8]
    0x804989e <main+314>    pop    ecx
    0x804989f <main+315>    pop    ebx
    ──────────────────────────────────────────────────────────────────────────────────────[ STACK ]───────────────────────────────────────────────────────────────────────────────────────00:0000│ esp 0xffffc400 ◂— 0x704c457f
    01:0004│-aa4 0xffffc404 ◂— 0x1d
    02:0008│-aa0 0xffffc408 ◂— 0x59 /* 'Y' */
    03:000c│-a9c 0xffffc40c ◂— 0x2e2e2e00
    04:0010│-a98 0xffffc410 ◂— 0x2e2e2e2e ('....')
    ... ↓        3 skipped
    ```
    Now, "test al al" is still 0, so "aaaa" is needed for the jump to win().  
    The coomand for win() is "aaaa"+"wwww"+"aaaa".

# Ref
- https://www.ta-oot.page/posts/ctf-writeups/picoctf2023/babygame01/
- https://www.ta-oot.page/posts/ctf-writeups/picoctf2023/babygame01/