# Lesson
- Sigreturn-oriented programming (SROP)  
  https://en.wikipedia.org/wiki/Sigreturn-oriented_programming  
- NX bit  
  whether shellcode is effective or not  
  https://d2v.hatenablog.com/entry/2021/06/24/003258  
  ```json
    {
      ...
      "nx": "no",
      ...
    }
  ```
  - Sigreturn-oriented programming (SROP)  
    - Stack hopping exploits   
    If mechanisms such as data execution prevention are employed, it won't be possible for the attacker to just place a shellcode on the stack and cause the machine to execute it by overwriting the return address. With such protections in place, the machine won't execute any code present in memory areas marked as writable and non-executable. Therefore, the attacker will need to reuse code already present in memory.

- `ROPgadget`  
  `ROPgadget` is installed with pwntools.
  ```zsh
  # use python3 with pwntools
  $ ROPgadget --binary ./vuln --re "pop ebx"
  ```
- how to input bytes value on stdin
  ```zsh
  (python -c "print 'a' * 76 + '\xe6\x85\x04\x08';") | ./vuln
  ```
  or
  ```zsh
  $ echo -e '\xdd\xcc\xbb\xaa%46c%6$n' | ./q4
  ```
  - how can I input bytes value during `pwndbg`  
    This does not work well.
    ```
    n << (python -c "print '\x90\x90'")
    n << (echo -e '\x90\x90')
    ```
- `execve`  
  https://en.wikipedia.org/wiki/Exec_(system_call)  
  https://wiki.mma.club.uec.ac.jp/ytoku/Slides/Pwn%E5%8B%89%E5%BC%B7%E4%BC%9A  
  https://manpages.ubuntu.com/manpages/focal/ja/man2/execve.2.html  
  - how to know the usage of `execve` on a machine code level
    1. qwrite simple c programe that use the system call - for instance `execve`  
        ```c
        #include <stdio.h>
        #include <unistd.h>

        int main() {
            // Specify the file name and arguments
            char *args[] = { "/bin/sh", "-l", NULL };

            // Specify environment variables
            char *envp[] = { NULL };

            // Call the execve system call and start a new process
            execve(args[0], args, envp);

            // This line will not be executed if the execve system call succeeds
            perror("execve failed");
            return 1;
        }
        ```
    2. compile it  
        When you exploit 32bit-OS, compile it on 32bit-OS.  
        When you exploit 64bit-OS, compile it on 64bit-OS. 
        ```zsh
        (32/64-OS)$ gcc test.c -o test.0
        ```
    3. debug it with `gdb` and check it  

# Quetions
- how to choose an arbitrary access
- why "/bin//sh", not "/bin/sh"
- `sysenter` vs. `int 80`

# Memo
1. check
    ```zsh
    $ file ./vuln
    ./vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, BuildID[sha1]=232215a502491a549a155b1a790de97f0c433482, for GNU/Linux 3.2.0, not stripped
    $ checksec --file=./vuln --output=json | jq .
    {
      "./vuln": {
        "relro": "partial",
        "canary": "no",
        "nx": "no",
        "pie": "no",
        "rpath": "n/a",
        "runpath": "n/a",
        "symbols": "yes",
        "fortify_source": "no",
        "fortified": "0",
        "fortify-able": "0"
      }
    }
    ```

2. `ghidra` and `gdb`  
get break point address  

3. write exploit  
- create ROP chain  
  - manual  
    x86  
    int 0x80  
    eax = 11  
    args: ebx, ecx, edx, esi, edi, ebp  

    ebx = (arbitrary address) -> /bin/sh  
    ecx = 0  
    edx = 0  

    ```
    $ ROPgadget --binary ./vuln --re "mov dword ptr" | grep ret
    ```
  - rely on `pwntools`  
    solver2.py  


# Ref  
- https://qiita.com/housu_jp/items/2be2b8147f35a4d6a6ce  